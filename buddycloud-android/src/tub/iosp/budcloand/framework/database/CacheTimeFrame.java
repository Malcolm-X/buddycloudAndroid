package tub.iosp.budcloand.framework.database;

import tub.iosp.budcloand.framework.database.DaoSession;
import de.greenrobot.dao.DaoException;

// THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT. Enable "keep" sections if you want to edit. 
/**
 * Entity mapped to table CACHE_TIME_FRAME.
 */
public class CacheTimeFrame {

    private Long id;
    private java.util.Date last;
    private java.util.Date first;
    private Long nextFrame;

    /** Used to resolve relations */
    private transient DaoSession daoSession;

    /** Used for active entity operations. */
    private transient CacheTimeFrameDao myDao;

    private CacheTimeFrame nextTimeFrame;
    private Long nextTimeFrame__resolvedKey;


    public CacheTimeFrame() {
    }

    public CacheTimeFrame(Long id) {
        this.id = id;
    }

    public CacheTimeFrame(Long id, java.util.Date last, java.util.Date first, Long nextFrame) {
        this.id = id;
        this.last = last;
        this.first = first;
        this.nextFrame = nextFrame;
    }

    /** called by internal mechanisms, do not call yourself. */
    public void __setDaoSession(DaoSession daoSession) {
        this.daoSession = daoSession;
        myDao = daoSession != null ? daoSession.getCacheTimeFrameDao() : null;
    }

    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public java.util.Date getLast() {
        return last;
    }

    public void setLast(java.util.Date last) {
        this.last = last;
    }

    public java.util.Date getFirst() {
        return first;
    }

    public void setFirst(java.util.Date first) {
        this.first = first;
    }

    public Long getNextFrame() {
        return nextFrame;
    }

    public void setNextFrame(Long nextFrame) {
        this.nextFrame = nextFrame;
    }

    /** To-one relationship, resolved on first access. */
    public CacheTimeFrame getNextTimeFrame() {
        if (nextTimeFrame__resolvedKey == null || !nextTimeFrame__resolvedKey.equals(nextFrame)) {
            if (daoSession == null) {
                throw new DaoException("Entity is detached from DAO context");
            }
            CacheTimeFrameDao targetDao = daoSession.getCacheTimeFrameDao();
            nextTimeFrame = targetDao.load(nextFrame);
            nextTimeFrame__resolvedKey = nextFrame;
        }
        return nextTimeFrame;
    }

    public void setNextTimeFrame(CacheTimeFrame nextTimeFrame) {
        this.nextTimeFrame = nextTimeFrame;
        nextFrame = nextTimeFrame == null ? null : nextTimeFrame.getId();
        nextTimeFrame__resolvedKey = nextFrame;
    }

    /** Convenient call for {@link AbstractDao#delete(Object)}. Entity must attached to an entity context. */
    public void delete() {
        if (myDao == null) {
            throw new DaoException("Entity is detached from DAO context");
        }    
        myDao.delete(this);
    }

    /** Convenient call for {@link AbstractDao#update(Object)}. Entity must attached to an entity context. */
    public void update() {
        if (myDao == null) {
            throw new DaoException("Entity is detached from DAO context");
        }    
        myDao.update(this);
    }

    /** Convenient call for {@link AbstractDao#refresh(Object)}. Entity must attached to an entity context. */
    public void refresh() {
        if (myDao == null) {
            throw new DaoException("Entity is detached from DAO context");
        }    
        myDao.refresh(this);
    }

}

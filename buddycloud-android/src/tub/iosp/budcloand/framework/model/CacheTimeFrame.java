package tub.iosp.budcloand.framework.model;

import tub.iosp.budcloand.framework.control.database.CacheTimeFrameDao;
import tub.iosp.budcloand.framework.control.database.DaoSession;
import de.greenrobot.dao.AbstractDao;
import de.greenrobot.dao.DaoException;

// TODO: Auto-generated Javadoc
// THIS CODE IS GENERATED BY greenDAO 
/**
 * Entity mapped to table CACHE_TIME_FRAME. Represents a timeframe in the cache.
 */
public class CacheTimeFrame {

    /** The id in the db. */
    private Long id;
    
    /** The time of the first item in the frame. */
    private java.util.Date last;
    
    /** The time of the last item in the frame . */
    private java.util.Date first;
    
    /** The id of the next frame in the cache. */
    private Long nextFrame;

    /** Used to resolve relations. */
    private transient DaoSession daoSession;

    /** Used for active entity operations. */
    private transient CacheTimeFrameDao myDao;

    /** The next time frame. */
    private CacheTimeFrame nextTimeFrame;
    
    /** The next time frame__resolved key. */
    private Long nextTimeFrame__resolvedKey;


    /**
     * Instantiates a new cache time frame.
     */
    public CacheTimeFrame() {
    }

    /**
     * Instantiates a new cache time frame.
     *
     * @param id the database id for this frame. 
     * Set to null to let the application manage your keys.
     */
    public CacheTimeFrame(Long id) {
        this.id = id;
    }

    /**
     * Instantiates a new cache time frame.
     *
     * @param id the id
     * Set to null to let the application manage your keys
     * @param last the last date in this frame
     * @param first the first date in this frame
     * @param nextFrame the next frame's id
     */
    public CacheTimeFrame(Long id, java.util.Date last, java.util.Date first, Long nextFrame) {
        this.id = id;
        this.last = last;
        this.first = first;
        this.nextFrame = nextFrame;
    }

    /**
     * called by internal mechanisms, do not call yourself.
     *
     * @param daoSession the dao session
     */
    public void __setDaoSession(DaoSession daoSession) {
        this.daoSession = daoSession;
        myDao = daoSession != null ? daoSession.getCacheTimeFrameDao() : null;
    }

    /**
     * Gets the id.
     *
     * @return the id in the db
     */
    public Long getId() {
        return id;
    }

    /**
     * Sets the id.
     *
     * @param id the new id. Setting this manually can corrupt your database
     */
    public void setId(Long id) {
        this.id = id;
    }

    /**
     * Gets the last date.
     *
     * @return the last date in the timeframe
     */
    public java.util.Date getLast() {
        return last;
    }

    /**
     * Sets the last date.
     *
     * @param last the new last date of the timeframe
     */
    public void setLast(java.util.Date last) {
        this.last = last;
    }

    /**
     * Gets the first date.
     *
     * @return the first date in the timeframe
     */
    public java.util.Date getFirst() {
        return first;
    }

    /**
     * Sets the first.
     *
     * @param first the new first date in the timeframe
     */
    public void setFirst(java.util.Date first) {
        this.first = first;
    }

    /**
     * Gets the next frame's id.
     *
     * @return the next frame's id or null
     */
    public Long getNextFrame() {
        return nextFrame;
    }

    /**
     * Sets the next frame.
     *
     * @param nextFrame the new id of next frame
     */
    public void setNextFrame(Long nextFrame) {
        this.nextFrame = nextFrame;
    }

    /**
     * To-one relationship, resolved on first access.
     *
     * @return the next timeframe
     */
    public CacheTimeFrame getNextTimeFrame() {
        if (nextTimeFrame__resolvedKey == null || !nextTimeFrame__resolvedKey.equals(nextFrame)) {
            if (daoSession == null) {
                throw new DaoException("Entity is detached from DAO context");
            }
            CacheTimeFrameDao targetDao = daoSession.getCacheTimeFrameDao();
            nextTimeFrame = targetDao.load(nextFrame);
            nextTimeFrame__resolvedKey = nextFrame;
        }
        return nextTimeFrame;
    }

    /**
     * Sets the next timeframe.
     *
     * @param nextTimeFrame the new next timeframe
     */
    public void setNextTimeFrame(CacheTimeFrame nextTimeFrame) {
        this.nextTimeFrame = nextTimeFrame;
        nextFrame = nextTimeFrame == null ? null : nextTimeFrame.getId();
        nextTimeFrame__resolvedKey = nextFrame;
    }

    /** Convenient call for {@link AbstractDao#delete(Object)}. Entity must attached to an entity context. */
    public void delete() {
        if (myDao == null) {
            throw new DaoException("Entity is detached from DAO context");
        }    
        myDao.delete(this);
    }

    /** Convenient call for {@link AbstractDao#update(Object)}. Entity must attached to an entity context. */
    public void update() {
        if (myDao == null) {
            throw new DaoException("Entity is detached from DAO context");
        }    
        myDao.update(this);
    }

    /** Convenient call for {@link AbstractDao#refresh(Object)}. Entity must attached to an entity context. */
    public void refresh() {
        if (myDao == null) {
            throw new DaoException("Entity is detached from DAO context");
        }    
        myDao.refresh(this);
    }

}
